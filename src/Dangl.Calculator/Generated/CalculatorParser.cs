//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.4-SNAPSHOT
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from Calculator.g4 by ANTLR 4.5.4-SNAPSHOT

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace Dangl.Calculator.Generated {

#pragma warning disable 0419
#pragma warning disable 3021
#pragma warning disable 1574
#pragma warning disable 1591
#pragma warning disable 1658
#pragma warning disable 1584
#pragma warning disable 0108

using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.4-SNAPSHOT")]
[System.CLSCompliant(false)]
public partial class CalculatorParser : Parser {
	public const int
		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, T__7=8, T__8=9, 
		NUMBER=10, FLOAT=11, DIGIT=12, MOD=13, WHOLE=14, MUL=15, DIV=16, ADD=17, 
		SUB=18, PI=19, EXPONENT=20, NEGEXPONENT=21, EULER=22, SQRT=23, SQR=24, 
		FLOOR=25, CEIL=26, ABS=27, ROUNDK=28, ROUND=29, TRUNC=30, SIN=31, COS=32, 
		TAN=33, COT=34, SINH=35, COSH=36, TANH=37, ARCSIN=38, ARCCOS=39, ARCTAN=40, 
		ARCTAN2=41, ARCCOT=42, EXP=43, LN=44, EEX=45, LOG=46, RAD=47, DEG=48, 
		WS=49, COM=50, INVALID=51;
	public const int
		RULE_calculator = 0, RULE_expression = 1, RULE_compileUnit = 2;
	public static readonly string[] ruleNames = {
		"calculator", "expression", "compileUnit"
	};

	private static readonly string[] _LiteralNames = {
		null, "'('", "';'", "')'", "'^'", "'**'", "'%'", "'~'", "'//'", "'()'", 
		null, null, null, null, null, "'*'", "'/'", "'+'", "'-'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, null, null, null, null, null, null, null, null, "NUMBER", 
		"FLOAT", "DIGIT", "MOD", "WHOLE", "MUL", "DIV", "ADD", "SUB", "PI", "EXPONENT", 
		"NEGEXPONENT", "EULER", "SQRT", "SQR", "FLOOR", "CEIL", "ABS", "ROUNDK", 
		"ROUND", "TRUNC", "SIN", "COS", "TAN", "COT", "SINH", "COSH", "TANH", 
		"ARCSIN", "ARCCOS", "ARCTAN", "ARCTAN2", "ARCCOT", "EXP", "LN", "EEX", 
		"LOG", "RAD", "DEG", "WS", "COM", "INVALID"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Calculator.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }


		protected const int EOF = Eof;

	public CalculatorParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class CalculatorContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CompileUnitContext compileUnit() {
			return GetRuleContext<CompileUnitContext>(0);
		}
		public CalculatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_calculator; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCalculator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CalculatorContext calculator() {
		CalculatorContext _localctx = new CalculatorContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_calculator);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6; expression(0);
			State = 8;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,0,_ctx) ) {
			case 1:
				{
				State = 7; compileUnit();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TanContext : ExpressionContext {
		public ITerminalNode TAN() { return GetToken(CalculatorParser.TAN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public TanContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTan(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CoshContext : ExpressionContext {
		public ITerminalNode COSH() { return GetToken(CalculatorParser.COSH, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CoshContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCosh(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SqRootContext : ExpressionContext {
		public IToken op;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public SqRootContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSqRoot(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NegExponentContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode NEGEXPONENT() { return GetToken(CalculatorParser.NEGEXPONENT, 0); }
		public NegExponentContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNegExponent(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExponentContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode EXPONENT() { return GetToken(CalculatorParser.EXPONENT, 0); }
		public ExponentContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExponent(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Arctan2Context : ExpressionContext {
		public ITerminalNode ARCTAN2() { return GetToken(CalculatorParser.ARCTAN2, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Arctan2Context(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArctan2(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MulDivContext : ExpressionContext {
		public IToken op;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public MulDivContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMulDiv(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ArcsinContext : ExpressionContext {
		public ITerminalNode ARCSIN() { return GetToken(CalculatorParser.ARCSIN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ArcsinContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArcsin(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnaryPlusContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public UnaryPlusContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryPlus(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ArccotContext : ExpressionContext {
		public ITerminalNode ARCCOT() { return GetToken(CalculatorParser.ARCCOT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ArccotContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArccot(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ArccosContext : ExpressionContext {
		public ITerminalNode ARCCOS() { return GetToken(CalculatorParser.ARCCOS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ArccosContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArccos(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class EulerContext : ExpressionContext {
		public ITerminalNode EULER() { return GetToken(CalculatorParser.EULER, 0); }
		public EulerContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEuler(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ArctanContext : ExpressionContext {
		public ITerminalNode ARCTAN() { return GetToken(CalculatorParser.ARCTAN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ArctanContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArctan(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesisContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ParenthesisContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesis(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AbsContext : ExpressionContext {
		public ITerminalNode ABS() { return GetToken(CalculatorParser.ABS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public AbsContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAbs(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NumberContext : ExpressionContext {
		public ITerminalNode NUMBER() { return GetToken(CalculatorParser.NUMBER, 0); }
		public NumberContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumber(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SinhContext : ExpressionContext {
		public ITerminalNode SINH() { return GetToken(CalculatorParser.SINH, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public SinhContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSinh(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RoundContext : ExpressionContext {
		public ITerminalNode ROUND() { return GetToken(CalculatorParser.ROUND, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public RoundContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRound(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TruncContext : ExpressionContext {
		public ITerminalNode TRUNC() { return GetToken(CalculatorParser.TRUNC, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public TruncContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrunc(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PiContext : ExpressionContext {
		public ITerminalNode PI() { return GetToken(CalculatorParser.PI, 0); }
		public PiContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPi(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TanhContext : ExpressionContext {
		public ITerminalNode TANH() { return GetToken(CalculatorParser.TANH, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public TanhContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTanh(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FloorContext : ExpressionContext {
		public ITerminalNode FLOOR() { return GetToken(CalculatorParser.FLOOR, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public FloorContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFloor(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LnContext : ExpressionContext {
		public ITerminalNode LN() { return GetToken(CalculatorParser.LN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public LnContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLn(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ModContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode MOD() { return GetToken(CalculatorParser.MOD, 0); }
		public ModContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMod(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogContext : ExpressionContext {
		public ITerminalNode LOG() { return GetToken(CalculatorParser.LOG, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public LogContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLog(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AddSubContext : ExpressionContext {
		public IToken op;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public AddSubContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddSub(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CosContext : ExpressionContext {
		public ITerminalNode COS() { return GetToken(CalculatorParser.COS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CosContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCos(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DegContext : ExpressionContext {
		public ITerminalNode DEG() { return GetToken(CalculatorParser.DEG, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public DegContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeg(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SqrtContext : ExpressionContext {
		public ITerminalNode SQRT() { return GetToken(CalculatorParser.SQRT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public SqrtContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSqrt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CotContext : ExpressionContext {
		public ITerminalNode COT() { return GetToken(CalculatorParser.COT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CotContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCot(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class WholeContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode WHOLE() { return GetToken(CalculatorParser.WHOLE, 0); }
		public WholeContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhole(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnaryContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public UnaryContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RadContext : ExpressionContext {
		public ITerminalNode RAD() { return GetToken(CalculatorParser.RAD, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public RadContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRad(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SqrContext : ExpressionContext {
		public ITerminalNode SQR() { return GetToken(CalculatorParser.SQR, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public SqrContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSqr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SinContext : ExpressionContext {
		public ITerminalNode SIN() { return GetToken(CalculatorParser.SIN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public SinContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSin(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class EexContext : ExpressionContext {
		public ITerminalNode EEX() { return GetToken(CalculatorParser.EEX, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public EexContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEex(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PowContext : ExpressionContext {
		public IToken op;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public PowContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPow(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CeilContext : ExpressionContext {
		public ITerminalNode CEIL() { return GetToken(CalculatorParser.CEIL, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CeilContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCeil(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpContext : ExpressionContext {
		public ITerminalNode EXP() { return GetToken(CalculatorParser.EXP, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ExpContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RoundkContext : ExpressionContext {
		public ITerminalNode ROUNDK() { return GetToken(CalculatorParser.ROUNDK, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public RoundkContext(ExpressionContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoundk(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 2;
		EnterRecursionRule(_localctx, 2, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 87;
			switch (_input.La(1)) {
			case FLOOR:
				{
				_localctx = new FloorContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 11; Match(FLOOR);
				State = 12; expression(40);
				}
				break;
			case CEIL:
				{
				_localctx = new CeilContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 13; Match(CEIL);
				State = 14; expression(39);
				}
				break;
			case ABS:
				{
				_localctx = new AbsContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 15; Match(ABS);
				State = 16; expression(38);
				}
				break;
			case ROUNDK:
				{
				_localctx = new RoundkContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 17; Match(ROUNDK);
				State = 18; Match(T__0);
				State = 19; expression(0);
				State = 20; Match(T__1);
				State = 21; expression(0);
				State = 22; Match(T__2);
				}
				break;
			case ROUND:
				{
				_localctx = new RoundContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 24; Match(ROUND);
				State = 25; expression(36);
				}
				break;
			case TRUNC:
				{
				_localctx = new TruncContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 26; Match(TRUNC);
				State = 27; expression(35);
				}
				break;
			case SIN:
				{
				_localctx = new SinContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 28; Match(SIN);
				State = 29; expression(34);
				}
				break;
			case COS:
				{
				_localctx = new CosContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 30; Match(COS);
				State = 31; expression(33);
				}
				break;
			case TAN:
				{
				_localctx = new TanContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 32; Match(TAN);
				State = 33; expression(32);
				}
				break;
			case COT:
				{
				_localctx = new CotContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 34; Match(COT);
				State = 35; expression(31);
				}
				break;
			case SINH:
				{
				_localctx = new SinhContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 36; Match(SINH);
				State = 37; expression(30);
				}
				break;
			case COSH:
				{
				_localctx = new CoshContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 38; Match(COSH);
				State = 39; expression(29);
				}
				break;
			case TANH:
				{
				_localctx = new TanhContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 40; Match(TANH);
				State = 41; expression(28);
				}
				break;
			case ARCSIN:
				{
				_localctx = new ArcsinContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 42; Match(ARCSIN);
				State = 43; expression(27);
				}
				break;
			case ARCCOS:
				{
				_localctx = new ArccosContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 44; Match(ARCCOS);
				State = 45; expression(26);
				}
				break;
			case ARCTAN:
				{
				_localctx = new ArctanContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 46; Match(ARCTAN);
				State = 47; expression(25);
				}
				break;
			case ARCTAN2:
				{
				_localctx = new Arctan2Context(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 48; Match(ARCTAN2);
				State = 49; Match(T__0);
				State = 50; expression(0);
				State = 51; Match(T__1);
				State = 52; expression(0);
				State = 53; Match(T__2);
				}
				break;
			case ARCCOT:
				{
				_localctx = new ArccotContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 55; Match(ARCCOT);
				State = 56; expression(23);
				}
				break;
			case EXP:
				{
				_localctx = new ExpContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 57; Match(EXP);
				State = 58; expression(22);
				}
				break;
			case LN:
				{
				_localctx = new LnContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 59; Match(LN);
				State = 60; expression(21);
				}
				break;
			case EEX:
				{
				_localctx = new EexContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 61; Match(EEX);
				State = 62; expression(20);
				}
				break;
			case LOG:
				{
				_localctx = new LogContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 63; Match(LOG);
				State = 64; expression(19);
				}
				break;
			case RAD:
				{
				_localctx = new RadContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 65; Match(RAD);
				State = 66; expression(18);
				}
				break;
			case DEG:
				{
				_localctx = new DegContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 67; Match(DEG);
				State = 68; expression(17);
				}
				break;
			case SQRT:
				{
				_localctx = new SqrtContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 69; Match(SQRT);
				State = 70; expression(16);
				}
				break;
			case SQR:
				{
				_localctx = new SqrContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 71; Match(SQR);
				State = 72; expression(15);
				}
				break;
			case NUMBER:
				{
				_localctx = new NumberContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 73; Match(NUMBER);
				}
				break;
			case T__0:
				{
				_localctx = new ParenthesisContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 74; Match(T__0);
				State = 75; expression(0);
				State = 76; Match(T__2);
				}
				break;
			case PI:
				{
				_localctx = new PiContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 78; Match(PI);
				State = 80;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,1,_ctx) ) {
				case 1:
					{
					State = 79; Match(T__8);
					}
					break;
				}
				}
				break;
			case EULER:
				{
				_localctx = new EulerContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 82; Match(EULER);
				}
				break;
			case SUB:
				{
				_localctx = new UnaryContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 83; Match(SUB);
				State = 84; expression(2);
				}
				break;
			case ADD:
				{
				_localctx = new UnaryPlusContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 85; Match(ADD);
				State = 86; expression(1);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 115;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,4,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 113;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,3,_ctx) ) {
					case 1:
						{
						_localctx = new PowContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 89;
						if (!(Precpred(_ctx, 14))) throw new FailedPredicateException(this, "Precpred(_ctx, 14)");
						State = 90;
						((PowContext)_localctx).op = _input.Lt(1);
						_la = _input.La(1);
						if ( !(_la==T__3 || _la==T__4) ) {
							((PowContext)_localctx).op = _errHandler.RecoverInline(this);
						} else {
							Consume();
						}
						State = 91; expression(15);
						}
						break;

					case 2:
						{
						_localctx = new ModContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 92;
						if (!(Precpred(_ctx, 13))) throw new FailedPredicateException(this, "Precpred(_ctx, 13)");
						State = 93;
						_la = _input.La(1);
						if ( !(_la==T__5 || _la==MOD) ) {
						_errHandler.RecoverInline(this);
						} else {
							Consume();
						}
						State = 94; expression(14);
						}
						break;

					case 3:
						{
						_localctx = new WholeContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 95;
						if (!(Precpred(_ctx, 12))) throw new FailedPredicateException(this, "Precpred(_ctx, 12)");
						State = 96; Match(WHOLE);
						State = 97; expression(13);
						}
						break;

					case 4:
						{
						_localctx = new SqRootContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 98;
						if (!(Precpred(_ctx, 11))) throw new FailedPredicateException(this, "Precpred(_ctx, 11)");
						State = 99;
						((SqRootContext)_localctx).op = _input.Lt(1);
						_la = _input.La(1);
						if ( !(_la==T__6 || _la==T__7) ) {
							((SqRootContext)_localctx).op = _errHandler.RecoverInline(this);
						} else {
							Consume();
						}
						State = 100; expression(12);
						}
						break;

					case 5:
						{
						_localctx = new MulDivContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 101;
						if (!(Precpred(_ctx, 10))) throw new FailedPredicateException(this, "Precpred(_ctx, 10)");
						State = 102;
						((MulDivContext)_localctx).op = _input.Lt(1);
						_la = _input.La(1);
						if ( !(_la==MUL || _la==DIV) ) {
							((MulDivContext)_localctx).op = _errHandler.RecoverInline(this);
						} else {
							Consume();
						}
						State = 103; expression(11);
						}
						break;

					case 6:
						{
						_localctx = new AddSubContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 104;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 105;
						((AddSubContext)_localctx).op = _input.Lt(1);
						_la = _input.La(1);
						if ( !(_la==ADD || _la==SUB) ) {
							((AddSubContext)_localctx).op = _errHandler.RecoverInline(this);
						} else {
							Consume();
						}
						State = 106; expression(10);
						}
						break;

					case 7:
						{
						_localctx = new ExponentContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 107;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 108; Match(EXPONENT);
						State = 109; expression(6);
						}
						break;

					case 8:
						{
						_localctx = new NegExponentContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 110;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 111; Match(NEGEXPONENT);
						State = 112; expression(5);
						}
						break;
					}
					} 
				}
				State = 117;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,4,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class CompileUnitContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(CalculatorParser.Eof, 0); }
		public CompileUnitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compileUnit; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICalculatorVisitor<TResult> typedVisitor = visitor as ICalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompileUnit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompileUnitContext compileUnit() {
		CompileUnitContext _localctx = new CompileUnitContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_compileUnit);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 118; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 1: return expression_sempred((ExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 14);

		case 1: return Precpred(_ctx, 13);

		case 2: return Precpred(_ctx, 12);

		case 3: return Precpred(_ctx, 11);

		case 4: return Precpred(_ctx, 10);

		case 5: return Precpred(_ctx, 9);

		case 6: return Precpred(_ctx, 5);

		case 7: return Precpred(_ctx, 4);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\x35{\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x3\x2\x3\x2\x5\x2\v\n\x2\x3\x3\x3\x3\x3\x3\x3\x3"+
		"\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3"+
		"\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3"+
		"\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3"+
		"\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3"+
		"\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3"+
		"\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x5\x3S\n\x3\x3\x3"+
		"\x3\x3\x3\x3\x3\x3\x3\x3\x5\x3Z\n\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3"+
		"\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3"+
		"\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\a\x3t\n\x3\f\x3\xE\x3w\v\x3"+
		"\x3\x4\x3\x4\x3\x4\x2\x2\x3\x4\x5\x2\x2\x4\x2\x6\x2\x2\a\x3\x2\x6\a\x4"+
		"\x2\b\b\xF\xF\x3\x2\t\n\x3\x2\x11\x12\x3\x2\x13\x14\xA0\x2\b\x3\x2\x2"+
		"\x2\x4Y\x3\x2\x2\x2\x6x\x3\x2\x2\x2\b\n\x5\x4\x3\x2\t\v\x5\x6\x4\x2\n"+
		"\t\x3\x2\x2\x2\n\v\x3\x2\x2\x2\v\x3\x3\x2\x2\x2\f\r\b\x3\x1\x2\r\xE\a"+
		"\x1B\x2\x2\xEZ\x5\x4\x3*\xF\x10\a\x1C\x2\x2\x10Z\x5\x4\x3)\x11\x12\a\x1D"+
		"\x2\x2\x12Z\x5\x4\x3(\x13\x14\a\x1E\x2\x2\x14\x15\a\x3\x2\x2\x15\x16\x5"+
		"\x4\x3\x2\x16\x17\a\x4\x2\x2\x17\x18\x5\x4\x3\x2\x18\x19\a\x5\x2\x2\x19"+
		"Z\x3\x2\x2\x2\x1A\x1B\a\x1F\x2\x2\x1BZ\x5\x4\x3&\x1C\x1D\a \x2\x2\x1D"+
		"Z\x5\x4\x3%\x1E\x1F\a!\x2\x2\x1FZ\x5\x4\x3$ !\a\"\x2\x2!Z\x5\x4\x3#\""+
		"#\a#\x2\x2#Z\x5\x4\x3\"$%\a$\x2\x2%Z\x5\x4\x3!&\'\a%\x2\x2\'Z\x5\x4\x3"+
		" ()\a&\x2\x2)Z\x5\x4\x3\x1F*+\a\'\x2\x2+Z\x5\x4\x3\x1E,-\a(\x2\x2-Z\x5"+
		"\x4\x3\x1D./\a)\x2\x2/Z\x5\x4\x3\x1C\x30\x31\a*\x2\x2\x31Z\x5\x4\x3\x1B"+
		"\x32\x33\a+\x2\x2\x33\x34\a\x3\x2\x2\x34\x35\x5\x4\x3\x2\x35\x36\a\x4"+
		"\x2\x2\x36\x37\x5\x4\x3\x2\x37\x38\a\x5\x2\x2\x38Z\x3\x2\x2\x2\x39:\a"+
		",\x2\x2:Z\x5\x4\x3\x19;<\a-\x2\x2<Z\x5\x4\x3\x18=>\a.\x2\x2>Z\x5\x4\x3"+
		"\x17?@\a/\x2\x2@Z\x5\x4\x3\x16\x41\x42\a\x30\x2\x2\x42Z\x5\x4\x3\x15\x43"+
		"\x44\a\x31\x2\x2\x44Z\x5\x4\x3\x14\x45\x46\a\x32\x2\x2\x46Z\x5\x4\x3\x13"+
		"GH\a\x19\x2\x2HZ\x5\x4\x3\x12IJ\a\x1A\x2\x2JZ\x5\x4\x3\x11KZ\a\f\x2\x2"+
		"LM\a\x3\x2\x2MN\x5\x4\x3\x2NO\a\x5\x2\x2OZ\x3\x2\x2\x2PR\a\x15\x2\x2Q"+
		"S\a\v\x2\x2RQ\x3\x2\x2\x2RS\x3\x2\x2\x2SZ\x3\x2\x2\x2TZ\a\x18\x2\x2UV"+
		"\a\x14\x2\x2VZ\x5\x4\x3\x4WX\a\x13\x2\x2XZ\x5\x4\x3\x3Y\f\x3\x2\x2\x2"+
		"Y\xF\x3\x2\x2\x2Y\x11\x3\x2\x2\x2Y\x13\x3\x2\x2\x2Y\x1A\x3\x2\x2\x2Y\x1C"+
		"\x3\x2\x2\x2Y\x1E\x3\x2\x2\x2Y \x3\x2\x2\x2Y\"\x3\x2\x2\x2Y$\x3\x2\x2"+
		"\x2Y&\x3\x2\x2\x2Y(\x3\x2\x2\x2Y*\x3\x2\x2\x2Y,\x3\x2\x2\x2Y.\x3\x2\x2"+
		"\x2Y\x30\x3\x2\x2\x2Y\x32\x3\x2\x2\x2Y\x39\x3\x2\x2\x2Y;\x3\x2\x2\x2Y"+
		"=\x3\x2\x2\x2Y?\x3\x2\x2\x2Y\x41\x3\x2\x2\x2Y\x43\x3\x2\x2\x2Y\x45\x3"+
		"\x2\x2\x2YG\x3\x2\x2\x2YI\x3\x2\x2\x2YK\x3\x2\x2\x2YL\x3\x2\x2\x2YP\x3"+
		"\x2\x2\x2YT\x3\x2\x2\x2YU\x3\x2\x2\x2YW\x3\x2\x2\x2Zu\x3\x2\x2\x2[\\\f"+
		"\x10\x2\x2\\]\t\x2\x2\x2]t\x5\x4\x3\x11^_\f\xF\x2\x2_`\t\x3\x2\x2`t\x5"+
		"\x4\x3\x10\x61\x62\f\xE\x2\x2\x62\x63\a\x10\x2\x2\x63t\x5\x4\x3\xF\x64"+
		"\x65\f\r\x2\x2\x65\x66\t\x4\x2\x2\x66t\x5\x4\x3\xEgh\f\f\x2\x2hi\t\x5"+
		"\x2\x2it\x5\x4\x3\rjk\f\v\x2\x2kl\t\x6\x2\x2lt\x5\x4\x3\fmn\f\a\x2\x2"+
		"no\a\x16\x2\x2ot\x5\x4\x3\bpq\f\x6\x2\x2qr\a\x17\x2\x2rt\x5\x4\x3\as["+
		"\x3\x2\x2\x2s^\x3\x2\x2\x2s\x61\x3\x2\x2\x2s\x64\x3\x2\x2\x2sg\x3\x2\x2"+
		"\x2sj\x3\x2\x2\x2sm\x3\x2\x2\x2sp\x3\x2\x2\x2tw\x3\x2\x2\x2us\x3\x2\x2"+
		"\x2uv\x3\x2\x2\x2v\x5\x3\x2\x2\x2wu\x3\x2\x2\x2xy\a\x2\x2\x3y\a\x3\x2"+
		"\x2\x2\a\nRYsu";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Dangl.Calculator.Generated
